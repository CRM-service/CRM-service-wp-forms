/*! wordpress-plugin 01-07-2019 15:05 - CRM-service */
!(function (global, factory) { typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.tippy = factory(); }(this, () => {
  function isObjectLiteral(value) { return {}.toString.call(value) === '[object Object]'; } function toArray(value) { return [].slice.call(value); } function getArrayOfElements(selector) { if (selector instanceof Element || isObjectLiteral(selector)) return [selector]; if (selector instanceof NodeList) return toArray(selector); if (Array.isArray(selector)) return selector; try { return toArray(document.querySelectorAll(selector)); } catch (_) { return []; } } function polyfillVirtualReferenceProps(reference) {
    reference.refObj = !0, reference.attributes = reference.attributes || {}, reference.setAttribute = function (key, val) { reference.attributes[key] = val; }, reference.getAttribute = function (key) { return reference.attributes[key]; }, reference.removeAttribute = function (key) { delete reference.attributes[key]; }, reference.hasAttribute = function (key) { return key in reference.attributes; }, reference.addEventListener = function () {}, reference.removeEventListener = function () {}, reference.classList = {
      classNames: {}, add(key) { return reference.classList.classNames[key] = !0; }, remove(key) { return delete reference.classList.classNames[key], !0; }, contains(key) { return key in reference.classList.classNames; },
    };
  } function prefix(property) { for (let prefixes = ['', 'webkit'], upperProp = property.charAt(0).toUpperCase() + property.slice(1), i = 0; i < prefixes.length; i++) { const _prefix = prefixes[i]; const prefixedProp = _prefix ? _prefix + upperProp : property; if (typeof document.body.style[prefixedProp] !== 'undefined') return prefixedProp; } return null; } function div() { return document.createElement('div'); } function createPopperElement(id, title, options) { const popper = div(); popper.setAttribute('class', 'tippy-popper'), popper.setAttribute('role', 'tooltip'), popper.setAttribute('id', `tippy-${id}`), popper.style.zIndex = options.zIndex, popper.style.maxWidth = options.maxWidth; const tooltip = div(); tooltip.setAttribute('class', 'tippy-tooltip'), tooltip.setAttribute('data-size', options.size), tooltip.setAttribute('data-animation', options.animation), tooltip.setAttribute('data-state', 'hidden'), options.theme.split(' ').forEach((t) => { tooltip.classList.add(`${t}-theme`); }); const content = div(); if (content.setAttribute('class', 'tippy-content'), options.arrow) { const arrow = div(); arrow.style[prefix('transform')] = options.arrowTransform, options.arrowType === 'round' ? (arrow.classList.add('tippy-roundarrow'), arrow.innerHTML = '<svg viewBox="0 0 24 8" xmlns="http://www.w3.org/2000/svg"><path d="M3 8s2.021-.015 5.253-4.218C9.584 2.051 10.797 1.007 12 1c1.203-.007 2.416 1.035 3.761 2.782C19.012 8.005 21 8 21 8H3z"/></svg>') : arrow.classList.add('tippy-arrow'), tooltip.appendChild(arrow); } if (options.animateFill) { tooltip.setAttribute('data-animatefill', ''); const backdrop = div(); backdrop.classList.add('tippy-backdrop'), backdrop.setAttribute('data-state', 'hidden'), tooltip.appendChild(backdrop); }options.inertia && tooltip.setAttribute('data-inertia', ''), options.interactive && tooltip.setAttribute('data-interactive', ''); const { html } = options; if (html) { let templateId = void 0; html instanceof Element ? (content.appendChild(html), templateId = `#${html.id || 'tippy-html-template'}`) : (content.innerHTML = document.querySelector(html).innerHTML, templateId = html), popper.setAttribute('data-html', ''), tooltip.setAttribute('data-template-id', templateId), options.interactive && popper.setAttribute('tabindex', '-1'); } else content[options.allowTitleHTML ? 'innerHTML' : 'textContent'] = title; return tooltip.appendChild(content), popper.appendChild(tooltip), popper; } function createTrigger(eventType, reference, handlers, options) {
    const { onTrigger } = handlers; const { onMouseLeave } = handlers; const { onBlur } = handlers; const { onDelegateShow } = handlers; const { onDelegateHide } = handlers; const
      listeners = []; if (eventType === 'manual') return listeners; const on = function (eventType, handler) { reference.addEventListener(eventType, handler), listeners.push({ event: eventType, handler }); }; return options.target ? (browser.supportsTouch && options.touchHold && (on('touchstart', onDelegateShow), on('touchend', onDelegateHide)), eventType === 'mouseenter' && (on('mouseover', onDelegateShow), on('mouseout', onDelegateHide)), eventType === 'focus' && (on('focusin', onDelegateShow), on('focusout', onDelegateHide)), eventType === 'click' && on('click', onDelegateShow)) : (on(eventType, onTrigger), browser.supportsTouch && options.touchHold && (on('touchstart', onTrigger), on('touchend', onMouseLeave)), eventType === 'mouseenter' && on('mouseleave', onMouseLeave), eventType === 'focus' && on(isIE ? 'focusout' : 'blur', onBlur)), listeners;
  } function getIndividualOptions(reference, instanceOptions) { const options = defaultsKeys.reduce((acc, key) => { let val = reference.getAttribute(`data-tippy-${key.toLowerCase()}`) || instanceOptions[key]; return val === 'false' && (val = !1), val === 'true' && (val = !0), isFinite(val) && !isNaN(parseFloat(val)) && (val = parseFloat(val)), key !== 'target' && typeof val === 'string' && val.trim().charAt(0) === '[' && (val = JSON.parse(val)), acc[key] = val, acc; }, {}); return { ...instanceOptions, ...options }; } function evaluateOptions(reference, options) { return options.arrow && (options.animateFill = !1), options.appendTo && typeof options.appendTo === 'function' && (options.appendTo = options.appendTo()), typeof options.html === 'function' && (options.html = options.html(reference)), options; } function getInnerElements(popper) {
    const select = function (s) { return popper.querySelector(s); }; return {
      tooltip: select(selectors.TOOLTIP), backdrop: select(selectors.BACKDROP), content: select(selectors.CONTENT), arrow: select(selectors.ARROW) || select(selectors.ROUND_ARROW),
    };
  } function removeTitle(el) { const title = el.getAttribute('title'); title && el.setAttribute('data-original-title', title), el.removeAttribute('title'); } function microtaskDebounce(fn) { let called = !1; return function () { called || (called = !0, window.Promise.resolve().then(() => { called = !1, fn(); })); }; } function taskDebounce(fn) { let scheduled = !1; return function () { scheduled || (scheduled = !0, setTimeout(() => { scheduled = !1, fn(); }, timeoutDuration)); }; } function isFunction(functionToCheck) { const getType = {}; return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]'; } function getStyleComputedProperty(element, property) { if (element.nodeType !== 1) return []; const css = getComputedStyle(element, null); return property ? css[property] : css; } function getParentNode(element) { return element.nodeName === 'HTML' ? element : element.parentNode || element.host; } function getScrollParent(element) { if (!element) return document.body; switch (element.nodeName) { case 'HTML': case 'BODY': return element.ownerDocument.body; case '#document': return element.body; } const _getStyleComputedProp = getStyleComputedProperty(element); const { overflow } = _getStyleComputedProp; const { overflowX } = _getStyleComputedProp; const { overflowY } = _getStyleComputedProp; return /(auto|scroll|overlay)/.test(overflow + overflowY + overflowX) ? element : getScrollParent(getParentNode(element)); } function isIE$1(version) { return version === 11 ? isIE11 : version === 10 ? isIE10 : isIE11 || isIE10; } function getOffsetParent(element) { if (!element) return document.documentElement; for (var noOffsetParent = isIE$1(10) ? document.body : null, { offsetParent } = element; offsetParent === noOffsetParent && element.nextElementSibling;)offsetParent = (element = element.nextElementSibling).offsetParent; const nodeName = offsetParent && offsetParent.nodeName; return nodeName && nodeName !== 'BODY' && nodeName !== 'HTML' ? ['TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static' ? getOffsetParent(offsetParent) : offsetParent : element ? element.ownerDocument.documentElement : document.documentElement; } function isOffsetContainer(element) { const { nodeName } = element; return nodeName !== 'BODY' && (nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element); } function getRoot(node) { return node.parentNode !== null ? getRoot(node.parentNode) : node; } function findCommonOffsetParent(element1, element2) { if (!(element1 && element1.nodeType && element2 && element2.nodeType)) return document.documentElement; const order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING; const start = order ? element1 : element2; const end = order ? element2 : element1; const range = document.createRange(); range.setStart(start, 0), range.setEnd(end, 0); const { commonAncestorContainer } = range; if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) return isOffsetContainer(commonAncestorContainer) ? commonAncestorContainer : getOffsetParent(commonAncestorContainer); const element1root = getRoot(element1); return element1root.host ? findCommonOffsetParent(element1root.host, element2) : findCommonOffsetParent(element1, getRoot(element2).host); } function getScroll(element) { const side = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'top'; const upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft'; const { nodeName } = element; if (nodeName === 'BODY' || nodeName === 'HTML') { const html = element.ownerDocument.documentElement; const scrollingElement = element.ownerDocument.scrollingElement || html; return scrollingElement[upperSide]; } return element[upperSide]; } function includeScroll(rect, element) { const subtract = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const scrollTop = getScroll(element, 'top'); const scrollLeft = getScroll(element, 'left'); const modifier = subtract ? -1 : 1; return rect.top += scrollTop * modifier, rect.bottom += scrollTop * modifier, rect.left += scrollLeft * modifier, rect.right += scrollLeft * modifier, rect; } function getBordersSize(styles, axis) { const sideA = axis === 'x' ? 'Left' : 'Top'; const sideB = sideA === 'Left' ? 'Right' : 'Bottom'; return parseFloat(styles[`border${sideA}Width`], 10) + parseFloat(styles[`border${sideB}Width`], 10); } function getSize(axis, body, html, computedStyle) { return Math.max(body[`offset${axis}`], body[`scroll${axis}`], html[`client${axis}`], html[`offset${axis}`], html[`scroll${axis}`], isIE$1(10) ? parseInt(html[`offset${axis}`]) + parseInt(computedStyle[`margin${axis === 'Height' ? 'Top' : 'Left'}`]) + parseInt(computedStyle[`margin${axis === 'Height' ? 'Bottom' : 'Right'}`]) : 0); } function getWindowSizes(document) {
    const { body } = document; const html = document.documentElement; const
      computedStyle = isIE$1(10) && getComputedStyle(html); return { height: getSize('Height', body, html, computedStyle), width: getSize('Width', body, html, computedStyle) };
  } function getClientRect(offsets) { return { ...offsets, right: offsets.left + offsets.width, bottom: offsets.top + offsets.height }; } function getBoundingClientRect(element) {
    let rect = {}; try { if (isIE$1(10)) { rect = element.getBoundingClientRect(); const scrollTop = getScroll(element, 'top'); const scrollLeft = getScroll(element, 'left'); rect.top += scrollTop, rect.left += scrollLeft, rect.bottom += scrollTop, rect.right += scrollLeft; } else rect = element.getBoundingClientRect(); } catch (e) {} const result = {
      left: rect.left, top: rect.top, width: rect.right - rect.left, height: rect.bottom - rect.top,
    }; const sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {}; const width = sizes.width || element.clientWidth || result.right - result.left; const height = sizes.height || element.clientHeight || result.bottom - result.top; let horizScrollbar = element.offsetWidth - width; let vertScrollbar = element.offsetHeight - height; if (horizScrollbar || vertScrollbar) { const styles = getStyleComputedProperty(element); horizScrollbar -= getBordersSize(styles, 'x'), vertScrollbar -= getBordersSize(styles, 'y'), result.width -= horizScrollbar, result.height -= vertScrollbar; } return getClientRect(result);
  } function getOffsetRectRelativeToArbitraryNode(children, parent) {
    const fixedPosition = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; const isIE10 = isIE$1(10); const isHTML = parent.nodeName === 'HTML'; const childrenRect = getBoundingClientRect(children); const parentRect = getBoundingClientRect(parent); const scrollParent = getScrollParent(children); const styles = getStyleComputedProperty(parent); const borderTopWidth = parseFloat(styles.borderTopWidth, 10); const borderLeftWidth = parseFloat(styles.borderLeftWidth, 10); fixedPosition && isHTML && (parentRect.top = Math.max(parentRect.top, 0), parentRect.left = Math.max(parentRect.left, 0)); let offsets = getClientRect({
      top: childrenRect.top - parentRect.top - borderTopWidth, left: childrenRect.left - parentRect.left - borderLeftWidth, width: childrenRect.width, height: childrenRect.height,
    }); if (offsets.marginTop = 0, offsets.marginLeft = 0, !isIE10 && isHTML) { const marginTop = parseFloat(styles.marginTop, 10); const marginLeft = parseFloat(styles.marginLeft, 10); offsets.top -= borderTopWidth - marginTop, offsets.bottom -= borderTopWidth - marginTop, offsets.left -= borderLeftWidth - marginLeft, offsets.right -= borderLeftWidth - marginLeft, offsets.marginTop = marginTop, offsets.marginLeft = marginLeft; } return (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') && (offsets = includeScroll(offsets, parent)), offsets;
  } function getViewportOffsetRectRelativeToArtbitraryNode(element) {
    const excludeScroll = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const html = element.ownerDocument.documentElement; const relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html); const width = Math.max(html.clientWidth, window.innerWidth || 0); const height = Math.max(html.clientHeight, window.innerHeight || 0); const scrollTop = excludeScroll ? 0 : getScroll(html); const scrollLeft = excludeScroll ? 0 : getScroll(html, 'left'); const offset = {
      top: scrollTop - relativeOffset.top + relativeOffset.marginTop, left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft, width, height,
    }; return getClientRect(offset);
  } function isFixed(element) { const { nodeName } = element; return nodeName !== 'BODY' && nodeName !== 'HTML' && (getStyleComputedProperty(element, 'position') === 'fixed' || isFixed(getParentNode(element))); } function getFixedPositionOffsetParent(element) { if (!element || !element.parentElement || isIE$1()) return document.documentElement; for (var el = element.parentElement; el && getStyleComputedProperty(el, 'transform') === 'none';)el = el.parentElement; return el || document.documentElement; } function getBoundaries(popper, reference, padding, boundariesElement) { const fixedPosition = arguments.length > 4 && void 0 !== arguments[4] && arguments[4]; let boundaries = { top: 0, left: 0 }; const offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference); if (boundariesElement === 'viewport')boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition); else { let boundariesNode = void 0; boundariesElement === 'scrollParent' ? (boundariesNode = getScrollParent(getParentNode(reference)), boundariesNode.nodeName === 'BODY' && (boundariesNode = popper.ownerDocument.documentElement)) : boundariesNode = boundariesElement === 'window' ? popper.ownerDocument.documentElement : boundariesElement; const offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition); if (boundariesNode.nodeName !== 'HTML' || isFixed(offsetParent))boundaries = offsets; else { const _getWindowSizes = getWindowSizes(popper.ownerDocument); const { height } = _getWindowSizes; const { width } = _getWindowSizes; boundaries.top += offsets.top - offsets.marginTop, boundaries.bottom = height + offsets.top, boundaries.left += offsets.left - offsets.marginLeft, boundaries.right = width + offsets.left; } }padding = padding || 0; const isPaddingNumber = typeof padding === 'number'; return boundaries.left += isPaddingNumber ? padding : padding.left || 0, boundaries.top += isPaddingNumber ? padding : padding.top || 0, boundaries.right -= isPaddingNumber ? padding : padding.right || 0, boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0, boundaries; } function getArea(_ref) {
    const { width } = _ref; const
      { height } = _ref; return width * height;
  } function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
    const padding = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0; if (placement.indexOf('auto') === -1) return placement; const boundaries = getBoundaries(popper, reference, padding, boundariesElement); const rects = {
      top: { width: boundaries.width, height: refRect.top - boundaries.top }, right: { width: boundaries.right - refRect.right, height: boundaries.height }, bottom: { width: boundaries.width, height: boundaries.bottom - refRect.bottom }, left: { width: refRect.left - boundaries.left, height: boundaries.height },
    }; const sortedAreas = Object.keys(rects).map((key) => ({ key, ...rects[key], area: getArea(rects[key]) })).sort((a, b) => b.area - a.area); const filteredAreas = sortedAreas.filter((_ref2) => {
      const { width } = _ref2; const
        { height } = _ref2; return width >= popper.clientWidth && height >= popper.clientHeight;
    }); const computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key; const variation = placement.split('-')[1]; return computedPlacement + (variation ? `-${variation}` : '');
  } function getReferenceOffsets(state, popper, reference) { const fixedPosition = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null; const commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference); return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition); } function getOuterSizes(element) { const styles = getComputedStyle(element); const x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom); const y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight); const result = { width: element.offsetWidth + y, height: element.offsetHeight + x }; return result; } function getOppositePlacement(placement) {
    const hash = {
      left: 'right', right: 'left', bottom: 'top', top: 'bottom',
    }; return placement.replace(/left|right|bottom|top/g, (matched) => hash[matched]);
  } function getPopperOffsets(popper, referenceOffsets, placement) { placement = placement.split('-')[0]; const popperRect = getOuterSizes(popper); const popperOffsets = { width: popperRect.width, height: popperRect.height }; const isHoriz = ['right', 'left'].indexOf(placement) !== -1; const mainSide = isHoriz ? 'top' : 'left'; const secondarySide = isHoriz ? 'left' : 'top'; const measurement = isHoriz ? 'height' : 'width'; const secondaryMeasurement = isHoriz ? 'width' : 'height'; return popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2, placement === secondarySide ? popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement] : popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)], popperOffsets; } function find(arr, check) { return Array.prototype.find ? arr.find(check) : arr.filter(check)[0]; } function findIndex(arr, prop, value) { if (Array.prototype.findIndex) return arr.findIndex((cur) => cur[prop] === value); const match = find(arr, (obj) => obj[prop] === value); return arr.indexOf(match); } function runModifiers(modifiers, data, ends) { const modifiersToRun = void 0 === ends ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends)); return modifiersToRun.forEach((modifier) => { modifier.function && console.warn('`modifier.function` is deprecated, use `modifier.fn`!'); const fn = modifier.function || modifier.fn; modifier.enabled && isFunction(fn) && (data.offsets.popper = getClientRect(data.offsets.popper), data.offsets.reference = getClientRect(data.offsets.reference), data = fn(data, modifier)); }), data; } function update() {
    if (!this.state.isDestroyed) {
      let data = {
        instance: this, styles: {}, arrowStyles: {}, attributes: {}, flipped: !1, offsets: {},
      }; data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed), data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding), data.originalPlacement = data.placement, data.positionFixed = this.options.positionFixed, data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement), data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute', data = runModifiers(this.modifiers, data), this.state.isCreated ? this.options.onUpdate(data) : (this.state.isCreated = !0, this.options.onCreate(data));
    }
  } function isModifierEnabled(modifiers, modifierName) {
    return modifiers.some((_ref) => {
      const { name } = _ref; const
        { enabled } = _ref; return enabled && name === modifierName;
    });
  } function getSupportedPropertyName(property) { for (let prefixes = [!1, 'ms', 'Webkit', 'Moz', 'O'], upperProp = property.charAt(0).toUpperCase() + property.slice(1), i = 0; i < prefixes.length; i++) { const prefix = prefixes[i]; const toCheck = prefix ? `${prefix}${upperProp}` : property; if (typeof document.body.style[toCheck] !== 'undefined') return toCheck; } return null; } function destroy() { return this.state.isDestroyed = !0, isModifierEnabled(this.modifiers, 'applyStyle') && (this.popper.removeAttribute('x-placement'), this.popper.style.position = '', this.popper.style.top = '', this.popper.style.left = '', this.popper.style.right = '', this.popper.style.bottom = '', this.popper.style.willChange = '', this.popper.style[getSupportedPropertyName('transform')] = ''), this.disableEventListeners(), this.options.removeOnDestroy && this.popper.parentNode.removeChild(this.popper), this; } function getWindow(element) { const { ownerDocument } = element; return ownerDocument ? ownerDocument.defaultView : window; } function attachToScrollParents(scrollParent, event, callback, scrollParents) { const isBody = scrollParent.nodeName === 'BODY'; const target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent; target.addEventListener(event, callback, { passive: !0 }), isBody || attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents), scrollParents.push(target); } function setupEventListeners(reference, options, state, updateBound) { state.updateBound = updateBound, getWindow(reference).addEventListener('resize', state.updateBound, { passive: !0 }); const scrollElement = getScrollParent(reference); return attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents), state.scrollElement = scrollElement, state.eventsEnabled = !0, state; } function enableEventListeners() { this.state.eventsEnabled || (this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate)); } function removeEventListeners(reference, state) { return getWindow(reference).removeEventListener('resize', state.updateBound), state.scrollParents.forEach((target) => { target.removeEventListener('scroll', state.updateBound); }), state.updateBound = null, state.scrollParents = [], state.scrollElement = null, state.eventsEnabled = !1, state; } function disableEventListeners() { this.state.eventsEnabled && (cancelAnimationFrame(this.scheduleUpdate), this.state = removeEventListeners(this.reference, this.state)); } function isNumeric(n) { return n !== '' && !isNaN(parseFloat(n)) && isFinite(n); } function setStyles(element, styles) { Object.keys(styles).forEach((prop) => { let unit = ''; ['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop]) && (unit = 'px'), element.style[prop] = styles[prop] + unit; }); } function setAttributes(element, attributes) { Object.keys(attributes).forEach((prop) => { const value = attributes[prop]; value !== !1 ? element.setAttribute(prop, attributes[prop]) : element.removeAttribute(prop); }); } function applyStyle(data) { return setStyles(data.instance.popper, data.styles), setAttributes(data.instance.popper, data.attributes), data.arrowElement && Object.keys(data.arrowStyles).length && setStyles(data.arrowElement, data.arrowStyles), data; } function applyStyleOnLoad(reference, popper, options, modifierOptions, state) { const referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed); const placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding); return popper.setAttribute('x-placement', placement), setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' }), options; } function computeStyle(data, options) {
    const { x } = options; const { y } = options; const { popper } = data.offsets; const
      legacyGpuAccelerationOption = find(data.instance.modifiers, (modifier) => modifier.name === 'applyStyle').gpuAcceleration; void 0 !== legacyGpuAccelerationOption && console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!'); const gpuAcceleration = void 0 !== legacyGpuAccelerationOption ? legacyGpuAccelerationOption : options.gpuAcceleration; const offsetParent = getOffsetParent(data.instance.popper); const offsetParentRect = getBoundingClientRect(offsetParent); const styles = { position: popper.position }; const offsets = {
      left: Math.floor(popper.left), top: Math.round(popper.top), bottom: Math.round(popper.bottom), right: Math.floor(popper.right),
    }; const sideA = x === 'bottom' ? 'top' : 'bottom'; const sideB = y === 'right' ? 'left' : 'right'; const prefixedProperty = getSupportedPropertyName('transform'); let left = void 0; let top = void 0; if (top = sideA === 'bottom' ? offsetParent.nodeName === 'HTML' ? -offsetParent.clientHeight + offsets.bottom : -offsetParentRect.height + offsets.bottom : offsets.top, left = sideB === 'right' ? offsetParent.nodeName === 'HTML' ? -offsetParent.clientWidth + offsets.right : -offsetParentRect.width + offsets.right : offsets.left, gpuAcceleration && prefixedProperty)styles[prefixedProperty] = `translate3d(${left}px, ${top}px, 0)`, styles[sideA] = 0, styles[sideB] = 0, styles.willChange = 'transform'; else { const invertTop = sideA === 'bottom' ? -1 : 1; const invertLeft = sideB === 'right' ? -1 : 1; styles[sideA] = top * invertTop, styles[sideB] = left * invertLeft, styles.willChange = `${sideA}, ${sideB}`; } const attributes = { 'x-placement': data.placement }; return data.attributes = { ...attributes, ...data.attributes }, data.styles = { ...styles, ...data.styles }, data.arrowStyles = { ...data.offsets.arrow, ...data.arrowStyles }, data;
  } function isModifierRequired(modifiers, requestingName, requestedName) { const requesting = find(modifiers, (_ref) => { const { name } = _ref; return name === requestingName; }); const isRequired = !!requesting && modifiers.some((modifier) => modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order); if (!isRequired) { const _requesting = `\`${requestingName}\``; const requested = `\`${requestedName}\``; console.warn(`${requested} modifier is required by ${_requesting} modifier in order to work, be sure to include it before ${_requesting}!`); } return isRequired; } function arrow(data, options) { let _data$offsets$arrow; if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) return data; let arrowElement = options.element; if (typeof arrowElement === 'string') { if (arrowElement = data.instance.popper.querySelector(arrowElement), !arrowElement) return data; } else if (!data.instance.popper.contains(arrowElement)) return console.warn('WARNING: `arrow.element` must be child of its popper element!'), data; const placement = data.placement.split('-')[0]; const _data$offsets = data.offsets; const { popper } = _data$offsets; const { reference } = _data$offsets; const isVertical = ['left', 'right'].indexOf(placement) !== -1; const len = isVertical ? 'height' : 'width'; const sideCapitalized = isVertical ? 'Top' : 'Left'; const side = sideCapitalized.toLowerCase(); const altSide = isVertical ? 'left' : 'top'; const opSide = isVertical ? 'bottom' : 'right'; const arrowElementSize = getOuterSizes(arrowElement)[len]; reference[opSide] - arrowElementSize < popper[side] && (data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize)), reference[side] + arrowElementSize > popper[opSide] && (data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide]), data.offsets.popper = getClientRect(data.offsets.popper); const center = reference[side] + reference[len] / 2 - arrowElementSize / 2; const css = getStyleComputedProperty(data.instance.popper); const popperMarginSide = parseFloat(css[`margin${sideCapitalized}`], 10); const popperBorderSide = parseFloat(css[`border${sideCapitalized}Width`], 10); let sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide; return sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0), data.arrowElement = arrowElement, data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty$1(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty$1(_data$offsets$arrow, altSide, ''), _data$offsets$arrow), data; } function getOppositeVariation(variation) { return variation === 'end' ? 'start' : variation === 'start' ? 'end' : variation; } function clockwise(placement) { const counter = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const index = validPlacements.indexOf(placement); const arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index)); return counter ? arr.reverse() : arr; } function flip(data, options) { if (isModifierEnabled(data.instance.modifiers, 'inner')) return data; if (data.flipped && data.placement === data.originalPlacement) return data; const boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed); let placement = data.placement.split('-')[0]; let placementOpposite = getOppositePlacement(placement); let variation = data.placement.split('-')[1] || ''; let flipOrder = []; switch (options.behavior) { case BEHAVIORS.FLIP: flipOrder = [placement, placementOpposite]; break; case BEHAVIORS.CLOCKWISE: flipOrder = clockwise(placement); break; case BEHAVIORS.COUNTERCLOCKWISE: flipOrder = clockwise(placement, !0); break; default: flipOrder = options.behavior; } return flipOrder.forEach((step, index) => { if (placement !== step || flipOrder.length === index + 1) return data; placement = data.placement.split('-')[0], placementOpposite = getOppositePlacement(placement); const popperOffsets = data.offsets.popper; const refOffsets = data.offsets.reference; const { floor } = Math; const overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom); const overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left); const overflowsRight = floor(popperOffsets.right) > floor(boundaries.right); const overflowsTop = floor(popperOffsets.top) < floor(boundaries.top); const overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom); const overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom; const isVertical = ['top', 'bottom'].indexOf(placement) !== -1; const flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom); (overlapsRef || overflowsBoundaries || flippedVariation) && (data.flipped = !0, (overlapsRef || overflowsBoundaries) && (placement = flipOrder[index + 1]), flippedVariation && (variation = getOppositeVariation(variation)), data.placement = placement + (variation ? `-${variation}` : ''), data.offsets.popper = { ...data.offsets.popper, ...getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement) }, data = runModifiers(data.instance.modifiers, data, 'flip')); }), data; } function keepTogether(data) { const _data$offsets = data.offsets; const { popper } = _data$offsets; const { reference } = _data$offsets; const placement = data.placement.split('-')[0]; const { floor } = Math; const isVertical = ['top', 'bottom'].indexOf(placement) !== -1; const side = isVertical ? 'right' : 'bottom'; const opSide = isVertical ? 'left' : 'top'; const measurement = isVertical ? 'width' : 'height'; return popper[side] < floor(reference[opSide]) && (data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement]), popper[opSide] > floor(reference[side]) && (data.offsets.popper[opSide] = floor(reference[side])), data; } function toValue(str, measurement, popperOffsets, referenceOffsets) { const split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/); const value = +split[1]; const unit = split[2]; if (!value) return str; if (unit.indexOf('%') === 0) { let element = void 0; switch (unit) { case '%p': element = popperOffsets; break; case '%': case '%r': default: element = referenceOffsets; } const rect = getClientRect(element); return rect[measurement] / 100 * value; } if (unit === 'vh' || unit === 'vw') { let size = void 0; return size = unit === 'vh' ? Math.max(document.documentElement.clientHeight, window.innerHeight || 0) : Math.max(document.documentElement.clientWidth, window.innerWidth || 0), size / 100 * value; } return value; } function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
    const offsets = [0, 0]; const useHeight = ['right', 'left'].indexOf(basePlacement) !== -1; const fragments = offset.split(/(\+|\-)/).map((frag) => frag.trim()); const divider = fragments.indexOf(find(fragments, (frag) => frag.search(/,|\s/) !== -1)); fragments[divider] && fragments[divider].indexOf(',') === -1 && console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.'); const splitRegex = /\s*,\s*|\s+/; let ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments]; return ops = ops.map((op, index) => {
      const measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width'; let mergeWithPrevious = !1; return op.reduce((a, b) => (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1 ? (a[a.length - 1] = b,
      mergeWithPrevious = !0, a) : mergeWithPrevious ? (a[a.length - 1] += b, mergeWithPrevious = !1, a) : a.concat(b)), []).map((str) => toValue(str, measurement, popperOffsets, referenceOffsets));
    }), ops.forEach((op, index) => { op.forEach((frag, index2) => { isNumeric(frag) && (offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1)); }); }), offsets;
  } function offset(data, _ref) {
    const { offset } = _ref; const { placement } = data; const _data$offsets = data.offsets; const { popper } = _data$offsets; const { reference } = _data$offsets; const basePlacement = placement.split('-')[0]; let
      offsets = void 0; return offsets = isNumeric(+offset) ? [+offset, 0] : parseOffset(offset, popper, reference, basePlacement), basePlacement === 'left' ? (popper.top += offsets[0], popper.left -= offsets[1]) : basePlacement === 'right' ? (popper.top += offsets[0], popper.left += offsets[1]) : basePlacement === 'top' ? (popper.left += offsets[0], popper.top -= offsets[1]) : basePlacement === 'bottom' && (popper.left += offsets[0], popper.top += offsets[1]), data.popper = popper, data;
  } function preventOverflow(data, options) { let boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper); data.instance.reference === boundariesElement && (boundariesElement = getOffsetParent(boundariesElement)); const transformProp = getSupportedPropertyName('transform'); const popperStyles = data.instance.popper.style; const { top } = popperStyles; const { left } = popperStyles; const transform = popperStyles[transformProp]; popperStyles.top = '', popperStyles.left = '', popperStyles[transformProp] = ''; const boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed); popperStyles.top = top, popperStyles.left = left, popperStyles[transformProp] = transform, options.boundaries = boundaries; const order = options.priority; let { popper } = data.offsets; const check = { primary(placement) { let value = popper[placement]; return popper[placement] < boundaries[placement] && !options.escapeWithReference && (value = Math.max(popper[placement], boundaries[placement])), defineProperty$1({}, placement, value); }, secondary(placement) { const mainSide = placement === 'right' ? 'left' : 'top'; let value = popper[mainSide]; return popper[placement] > boundaries[placement] && !options.escapeWithReference && (value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height))), defineProperty$1({}, mainSide, value); } }; return order.forEach((placement) => { const side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary'; popper = { ...popper, ...check[side](placement) }; }), data.offsets.popper = popper, data; } function shift(data) {
    const { placement } = data; const basePlacement = placement.split('-')[0]; const
      shiftvariation = placement.split('-')[1]; if (shiftvariation) { const _data$offsets = data.offsets; const { reference } = _data$offsets; const { popper } = _data$offsets; const isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1; const side = isVertical ? 'left' : 'top'; const measurement = isVertical ? 'width' : 'height'; const shiftOffsets = { start: defineProperty$1({}, side, reference[side]), end: defineProperty$1({}, side, reference[side] + reference[measurement] - popper[measurement]) }; data.offsets.popper = { ...popper, ...shiftOffsets[shiftvariation] }; } return data;
  } function hide(data) { if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) return data; const refRect = data.offsets.reference; const bound = find(data.instance.modifiers, (modifier) => modifier.name === 'preventOverflow').boundaries; if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) { if (data.hide === !0) return data; data.hide = !0, data.attributes['x-out-of-boundaries'] = ''; } else { if (data.hide === !1) return data; data.hide = !1, data.attributes['x-out-of-boundaries'] = !1; } return data; } function inner(data) {
    const { placement } = data; const basePlacement = placement.split('-')[0]; const _data$offsets = data.offsets; const { popper } = _data$offsets; const { reference } = _data$offsets; const isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1; const
      subtractLength = ['top', 'left'].indexOf(basePlacement) === -1; return popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0), data.placement = getOppositePlacement(placement), data.offsets.popper = getClientRect(popper), data;
  } function reflow(popper) { void popper.offsetHeight; } function updatePopperPosition(popperInstance, callback, updateAlreadyCalled) {
    const { popper } = popperInstance; const { options } = popperInstance; const { onCreate } = options; const
      { onUpdate } = options; options.onCreate = options.onUpdate = function () { reflow(popper), callback && callback(), onUpdate(), options.onCreate = onCreate, options.onUpdate = onUpdate; }, updateAlreadyCalled || popperInstance.scheduleUpdate();
  } function getPopperPlacement(popper) { return popper.getAttribute('x-placement').replace(/-.+/, ''); } function cursorIsOutsideInteractiveBorder(event, popper, options) {
    if (!popper.getAttribute('x-placement')) return !0; const x = event.clientX; const y = event.clientY; const { interactiveBorder } = options; const { distance } = options; const rect = popper.getBoundingClientRect(); const placement = getPopperPlacement(popper); const borderWithDistance = interactiveBorder + distance; const exceeds = {
      top: rect.top - y > interactiveBorder, bottom: y - rect.bottom > interactiveBorder, left: rect.left - x > interactiveBorder, right: x - rect.right > interactiveBorder,
    }; switch (placement) { case 'top': exceeds.top = rect.top - y > borderWithDistance; break; case 'bottom': exceeds.bottom = y - rect.bottom > borderWithDistance; break; case 'left': exceeds.left = rect.left - x > borderWithDistance; break; case 'right': exceeds.right = x - rect.right > borderWithDistance; } return exceeds.top || exceeds.bottom || exceeds.left || exceeds.right;
  } function transformNumbersBasedOnPlacementAxis(type, numbers, isVertical, isReverse) { if (!numbers.length) return ''; const transforms = { scale: (function () { return numbers.length === 1 ? `${numbers[0]}` : isVertical ? `${numbers[0]}, ${numbers[1]}` : `${numbers[1]}, ${numbers[0]}`; }()), translate: (function () { return numbers.length === 1 ? isReverse ? `${-numbers[0]}px` : `${numbers[0]}px` : isVertical ? isReverse ? `${numbers[0]}px, ${-numbers[1]}px` : `${numbers[0]}px, ${numbers[1]}px` : isReverse ? `${-numbers[1]}px, ${numbers[0]}px` : `${numbers[1]}px, ${numbers[0]}px`; }()) }; return transforms[type]; } function transformAxis(axis, isVertical) { if (!axis) return ''; const map = { X: 'Y', Y: 'X' }; return isVertical ? axis : map[axis]; } function computeArrowTransform(popper, arrow, arrowTransform) { const placement = getPopperPlacement(popper); const isVertical = placement === 'top' || placement === 'bottom'; const isReverse = placement === 'right' || placement === 'bottom'; const getAxis = function (re) { const match = arrowTransform.match(re); return match ? match[1] : ''; }; const getNumbers = function (re) { const match = arrowTransform.match(re); return match ? match[1].split(',').map(parseFloat) : []; }; const re = { translate: /translateX?Y?\(([^)]+)\)/, scale: /scaleX?Y?\(([^)]+)\)/ }; const matches = { translate: { axis: getAxis(/translate([XY])/), numbers: getNumbers(re.translate) }, scale: { axis: getAxis(/scale([XY])/), numbers: getNumbers(re.scale) } }; const computedTransform = arrowTransform.replace(re.translate, `translate${transformAxis(matches.translate.axis, isVertical)}(${transformNumbersBasedOnPlacementAxis('translate', matches.translate.numbers, isVertical, isReverse)})`).replace(re.scale, `scale${transformAxis(matches.scale.axis, isVertical)}(${transformNumbersBasedOnPlacementAxis('scale', matches.scale.numbers, isVertical, isReverse)})`); arrow.style[prefix('transform')] = computedTransform; } function getOffsetDistanceInPx(distance) { return `${-(distance - defaults.distance)}px`; } function closest(element, parentSelector) { const fn = Element.prototype.closest || function (selector) { for (let el = this; el;) { if (matches$1.call(el, selector)) return el; el = el.parentElement; } }; return fn.call(element, parentSelector); } function getValue(value, index) { return Array.isArray(value) ? value[index] : value; } function setVisibilityState(els, type) { els.forEach((el) => { el && el.setAttribute('data-state', type); }); } function applyTransitionDuration(els, value) { els.filter(Boolean).forEach((el) => { el.style[prefix('transitionDuration')] = `${value}ms`; }); } function focus(el) { const x = window.scrollX || window.pageXOffset; const y = window.scrollY || window.pageYOffset; el.focus(), scroll(x, y); } function _hasFollowCursorBehavior() { const { lastTriggerEvent } = this._(key); return this.options.followCursor && !browser.usingTouch && lastTriggerEvent && lastTriggerEvent.type !== 'focus'; } function _createDelegateChildTippy(event) { const targetEl = closest(event.target, this.options.target); if (targetEl && !targetEl._tippy) { const title = targetEl.getAttribute('title') || this.title; title && (targetEl.setAttribute('title', title), tippy(targetEl, { ...this.options, target: null }), _enter.call(targetEl._tippy, event)); } } function _enter(event) { const _this4 = this; const { options } = this; if (_clearDelayTimeouts.call(this), !this.state.visible) { if (options.target) return void _createDelegateChildTippy.call(this, event); if (this._(key).isPreparingToShow = !0, options.wait) return void options.wait.call(this.popper, this.show.bind(this), event); if (_hasFollowCursorBehavior.call(this)) { this._(key).followCursorListener || _setFollowCursorListener.call(this); const _getInnerElements3 = getInnerElements(this.popper); const { arrow } = _getInnerElements3; arrow && (arrow.style.margin = '0'), document.addEventListener('mousemove', this._(key).followCursorListener); } const delay = getValue(options.delay, 0); delay ? this._(key).showTimeout = setTimeout(() => { _this4.show(); }, delay) : this.show(); } } function _leave() { const _this5 = this; if (_clearDelayTimeouts.call(this), this.state.visible) { this._(key).isPreparingToShow = !1; const delay = getValue(this.options.delay, 1); delay ? this._(key).hideTimeout = setTimeout(() => { _this5.state.visible && _this5.hide(); }, delay) : this.hide(); } } function _getEventListeners() {
    const _this6 = this; const onTrigger = function (event) { if (_this6.state.enabled) { const shouldStopEvent = browser.supportsTouch && browser.usingTouch && ['mouseenter', 'mouseover', 'focus'].indexOf(event.type) > -1; shouldStopEvent && _this6.options.touchHold || (_this6._(key).lastTriggerEvent = event, event.type === 'click' && _this6.options.hideOnClick !== 'persistent' && _this6.state.visible ? _leave.call(_this6) : _enter.call(_this6, event)); } }; const onMouseLeave = function (event) { if (!(['mouseleave', 'mouseout'].indexOf(event.type) > -1 && browser.supportsTouch && browser.usingTouch && _this6.options.touchHold)) { if (_this6.options.interactive) { const hide = _leave.bind(_this6); const onMouseMove = function onMouseMove(event) { const referenceCursorIsOver = closest(event.target, selectors.REFERENCE); const cursorIsOverPopper = closest(event.target, selectors.POPPER) === _this6.popper; const cursorIsOverReference = referenceCursorIsOver === _this6.reference; cursorIsOverPopper || cursorIsOverReference || cursorIsOutsideInteractiveBorder(event, _this6.popper, _this6.options) && (document.body.removeEventListener('mouseleave', hide), document.removeEventListener('mousemove', onMouseMove), _leave.call(_this6, onMouseMove)); }; return document.body.addEventListener('mouseleave', hide), void document.addEventListener('mousemove', onMouseMove); }_leave.call(_this6); } }; const onBlur = function (event) { if (event.target === _this6.reference && !browser.usingTouch) { if (_this6.options.interactive) { if (!event.relatedTarget) return; if (closest(event.relatedTarget, selectors.POPPER)) return; }_leave.call(_this6); } }; const onDelegateShow = function (event) { closest(event.target, _this6.options.target) && _enter.call(_this6, event); }; const onDelegateHide = function (event) { closest(event.target, _this6.options.target) && _leave.call(_this6); }; return {
      onTrigger, onMouseLeave, onBlur, onDelegateShow, onDelegateHide,
    };
  } function _createPopperInstance() {
    const _this7 = this; const { popper } = this; const { reference } = this; const { options } = this; const _getInnerElements4 = getInnerElements(popper); const { tooltip } = _getInnerElements4; const { popperOptions } = options; const arrowSelector = options.arrowType === 'round' ? selectors.ROUND_ARROW : selectors.ARROW; const arrow = tooltip.querySelector(arrowSelector); const config = {
      placement: options.placement,
      ...popperOptions || {},
      modifiers: {
        ...(popperOptions ? popperOptions.modifiers : {}),
        arrow: { element: arrowSelector, ...(popperOptions && popperOptions.modifiers ? popperOptions.modifiers.arrow : {}) },
        flip: {
          enabled: options.flip, padding: options.distance + 5, behavior: options.flipBehavior, ...(popperOptions && popperOptions.modifiers ? popperOptions.modifiers.flip : {}),
        },
        offset: { offset: options.offset, ...(popperOptions && popperOptions.modifiers ? popperOptions.modifiers.offset : {}) },
      },
      onCreate() { tooltip.style[getPopperPlacement(popper)] = getOffsetDistanceInPx(options.distance), arrow && options.arrowTransform && computeArrowTransform(popper, arrow, options.arrowTransform); },
      onUpdate() { const styles = tooltip.style; styles.top = '', styles.bottom = '', styles.left = '', styles.right = '', styles[getPopperPlacement(popper)] = getOffsetDistanceInPx(options.distance), arrow && options.arrowTransform && computeArrowTransform(popper, arrow, options.arrowTransform); },
    }; return _addMutationObserver.call(this, { target: popper, callback() { _this7.popperInstance.update(); }, options: { childList: !0, subtree: !0, characterData: !0 } }), new Popper(reference, popper, config);
  } function _mount(callback) { const { options } = this; if (this.popperInstance ? (this.popperInstance.scheduleUpdate(), options.livePlacement && !_hasFollowCursorBehavior.call(this) && this.popperInstance.enableEventListeners()) : (this.popperInstance = _createPopperInstance.call(this), options.livePlacement || this.popperInstance.disableEventListeners()), !_hasFollowCursorBehavior.call(this)) { const _getInnerElements5 = getInnerElements(this.popper); const { arrow } = _getInnerElements5; arrow && (arrow.style.margin = ''), this.popperInstance.reference = this.reference; }updatePopperPosition(this.popperInstance, callback, !0), options.appendTo.contains(this.popper) || options.appendTo.appendChild(this.popper); } function _clearDelayTimeouts() { const _ref = this._(key); const { showTimeout } = _ref; const { hideTimeout } = _ref; clearTimeout(showTimeout), clearTimeout(hideTimeout); } function _setFollowCursorListener() {
    const _this8 = this; this._(key).followCursorListener = function (event) {
      const _$lastMouseMoveEvent = _this8._(key).lastMouseMoveEvent = event; const { clientX } = _$lastMouseMoveEvent; const { clientY } = _$lastMouseMoveEvent; _this8.popperInstance && (_this8.popperInstance.reference = {
        getBoundingClientRect() {
          return {
            width: 0, height: 0, top: clientY, left: clientX, right: clientX, bottom: clientY,
          };
        },
        clientWidth: 0,
        clientHeight: 0,
      }, _this8.popperInstance.scheduleUpdate());
    };
  } function _makeSticky() { const _this9 = this; const applyTransitionDuration$$1 = function () { _this9.popper.style[prefix('transitionDuration')] = `${_this9.options.updateDuration}ms`; }; const removeTransitionDuration = function () { _this9.popper.style[prefix('transitionDuration')] = ''; }; const updatePosition = function updatePosition() { _this9.popperInstance && _this9.popperInstance.update(), applyTransitionDuration$$1(), _this9.state.visible ? requestAnimationFrame(updatePosition) : removeTransitionDuration(); }; updatePosition(); } function _addMutationObserver(_ref2) {
    const { target } = _ref2; const { callback } = _ref2; const
      { options } = _ref2; if (window.MutationObserver) { const observer = new MutationObserver(callback); observer.observe(target, options), this._(key).mutationObservers.push(observer); }
  } function _onTransitionEnd(duration, callback) { if (!duration) return callback(); const _getInnerElements6 = getInnerElements(this.popper); const { tooltip } = _getInnerElements6; const toggleListeners = function (action, listener) { listener && tooltip[`${action}EventListener`]('transition' in document.body.style ? 'transitionend' : 'webkitTransitionEnd', listener); }; const listener = function listener(e) { e.target === tooltip && (toggleListeners('remove', listener), callback()); }; toggleListeners('remove', this._(key).transitionendListener), toggleListeners('add', listener), this._(key).transitionendListener = listener; } function createTooltips(els, config) {
    return els.reduce((acc, reference) => {
      const id = idCounter; const options = evaluateOptions(reference, config.performance ? config : getIndividualOptions(reference, config)); const title = reference.getAttribute('title'); if (!(title || options.target || options.html || options.dynamicTitle)) return acc; reference.setAttribute(options.target ? 'data-tippy-delegate' : 'data-tippy', ''), removeTitle(reference); const popper = createPopperElement(id, title, options); const tippy = new Tippy({
        id, reference, popper, options, title, popperInstance: null,
      }); options.createPopperInstanceOnInit && (tippy.popperInstance = _createPopperInstance.call(tippy), tippy.popperInstance.disableEventListeners()); const listeners = _getEventListeners.call(tippy); return tippy.listeners = options.trigger.trim().split(' ').reduce((acc, eventType) => acc.concat(createTrigger(eventType, reference, listeners, options)), []), options.dynamicTitle && _addMutationObserver.call(tippy, { target: reference, callback() { const _getInnerElements = getInnerElements(popper); const { content } = _getInnerElements; const title = reference.getAttribute('title'); title && (content[options.allowTitleHTML ? 'innerHTML' : 'textContent'] = tippy.title = title, removeTitle(reference)); }, options: { attributes: !0 } }), reference._tippy = tippy, popper._tippy = tippy, popper._reference = reference, acc.push(tippy), idCounter++, acc;
    }, []);
  } function hideAllPoppers(excludeTippy) { const poppers = toArray(document.querySelectorAll(selectors.POPPER)); poppers.forEach((popper) => { const tippy = popper._tippy; if (tippy) { const { options } = tippy; !(options.hideOnClick === !0 || options.trigger.indexOf('focus') > -1) || excludeTippy && popper === excludeTippy.popper || tippy.hide(); } }); } function bindEventListeners(useCapture) {
    const onDocumentTouch = function () { browser.usingTouch || (browser.usingTouch = !0, browser.iOS && document.body.classList.add('tippy-touch'), browser.dynamicInputDetection && window.performance && document.addEventListener('mousemove', onDocumentMouseMove), browser.onUserInputChange('touch')); }; var onDocumentMouseMove = (function () { let time = void 0; return function () { const now = performance.now(); now - time < 20 && (browser.usingTouch = !1, document.removeEventListener('mousemove', onDocumentMouseMove), browser.iOS || document.body.classList.remove('tippy-touch'), browser.onUserInputChange('mouse')), time = now; }; }()); const onDocumentClick = function (event) {
      if (!(event.target instanceof Element)) return hideAllPoppers(); const reference = closest(event.target, selectors.REFERENCE); const popper = closest(event.target, selectors.POPPER); if (!(popper && popper._tippy && popper._tippy.options.interactive)) {
        if (reference && reference._tippy) {
          const { options } = reference._tippy; const isClickTrigger = options.trigger.indexOf('click') > -1; const
            isMultiple = options.multiple; if (!isMultiple && browser.usingTouch || !isMultiple && isClickTrigger) return hideAllPoppers(reference._tippy); if (options.hideOnClick !== !0 || isClickTrigger) return;
        }hideAllPoppers();
      }
    }; const onWindowBlur = function () { const _document = document; const el = _document.activeElement; el && el.blur && matches$1.call(el, selectors.REFERENCE) && el.blur(); }; const onWindowResize = function () { toArray(document.querySelectorAll(selectors.POPPER)).forEach((popper) => { const tippyInstance = popper._tippy; tippyInstance && !tippyInstance.options.livePlacement && tippyInstance.popperInstance.scheduleUpdate(); }); }; document.addEventListener('click', onDocumentClick, useCapture), document.addEventListener('touchstart', onDocumentTouch), window.addEventListener('blur', onWindowBlur), window.addEventListener('resize', onWindowResize), browser.supportsTouch || !navigator.maxTouchPoints && !navigator.msMaxTouchPoints || document.addEventListener('pointerdown', onDocumentTouch);
  } function tippy(selector, options, one) {
    browser.supported && !eventListenersBound && (bindEventListeners(useCapture), eventListenersBound = !0), isObjectLiteral(selector) && polyfillVirtualReferenceProps(selector), options = { ...defaults, ...options }; const references = getArrayOfElements(selector); const firstReference = references[0]; return {
      selector, options, tooltips: browser.supported ? createTooltips(one && firstReference ? [firstReference] : references, options) : [], destroyAll() { this.tooltips.forEach((tooltip) => tooltip.destroy()), this.tooltips = []; },
    };
  } function injectCSS() { const css = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ''; if (isBrowser && browser.supported) { const head = document.head || document.querySelector('head'); const style = document.createElement('style'); style.type = 'text/css', head.insertBefore(style, head.firstChild), style.styleSheet ? style.styleSheet.cssText = css : style.appendChild(document.createTextNode(css)); } } const styles = '.tippy-touch{cursor:pointer!important}.tippy-notransition{transition:none!important}.tippy-popper{max-width:350px;-webkit-perspective:700px;perspective:700px;z-index:9999;outline:0;transition-timing-function:cubic-bezier(.165,.84,.44,1);pointer-events:none;line-height:1.4}.tippy-popper[data-html]{max-width:96%;max-width:calc(100% - 20px)}.tippy-popper[x-placement^=top] .tippy-backdrop{border-radius:40% 40% 0 0}.tippy-popper[x-placement^=top] .tippy-roundarrow{bottom:-8px;-webkit-transform-origin:50% 0;transform-origin:50% 0}.tippy-popper[x-placement^=top] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(180deg);transform:rotate(180deg)}.tippy-popper[x-placement^=top] .tippy-arrow{border-top:7px solid #333;border-right:7px solid transparent;border-left:7px solid transparent;bottom:-7px;margin:0 6px;-webkit-transform-origin:50% 0;transform-origin:50% 0}.tippy-popper[x-placement^=top] .tippy-backdrop{-webkit-transform-origin:0 90%;transform-origin:0 90%}.tippy-popper[x-placement^=top] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(6) translate(-50%,25%);transform:scale(6) translate(-50%,25%);opacity:1}.tippy-popper[x-placement^=top] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(1) translate(-50%,25%);transform:scale(1) translate(-50%,25%);opacity:0}.tippy-popper[x-placement^=top] [data-animation=shift-toward][data-state=visible]{opacity:1;-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateY(-20px);transform:translateY(-20px)}.tippy-popper[x-placement^=top] [data-animation=perspective]{-webkit-transform-origin:bottom;transform-origin:bottom}.tippy-popper[x-placement^=top] [data-animation=perspective][data-state=visible]{opacity:1;-webkit-transform:translateY(-10px) rotateX(0);transform:translateY(-10px) rotateX(0)}.tippy-popper[x-placement^=top] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:translateY(0) rotateX(90deg);transform:translateY(0) rotateX(90deg)}.tippy-popper[x-placement^=top] [data-animation=fade][data-state=visible]{opacity:1;-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-away][data-state=visible]{opacity:1;-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-away][data-state=hidden]{opacity:0;-webkit-transform:translateY(0);transform:translateY(0)}.tippy-popper[x-placement^=top] [data-animation=scale][data-state=visible]{opacity:1;-webkit-transform:translateY(-10px) scale(1);transform:translateY(-10px) scale(1)}.tippy-popper[x-placement^=top] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateY(0) scale(0);transform:translateY(0) scale(0)}.tippy-popper[x-placement^=bottom] .tippy-backdrop{border-radius:0 0 30% 30%}.tippy-popper[x-placement^=bottom] .tippy-roundarrow{top:-8px;-webkit-transform-origin:50% 100%;transform-origin:50% 100%}.tippy-popper[x-placement^=bottom] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(0);transform:rotate(0)}.tippy-popper[x-placement^=bottom] .tippy-arrow{border-bottom:7px solid #333;border-right:7px solid transparent;border-left:7px solid transparent;top:-7px;margin:0 6px;-webkit-transform-origin:50% 100%;transform-origin:50% 100%}.tippy-popper[x-placement^=bottom] .tippy-backdrop{-webkit-transform-origin:0 -90%;transform-origin:0 -90%}.tippy-popper[x-placement^=bottom] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(6) translate(-50%,-125%);transform:scale(6) translate(-50%,-125%);opacity:1}.tippy-popper[x-placement^=bottom] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(1) translate(-50%,-125%);transform:scale(1) translate(-50%,-125%);opacity:0}.tippy-popper[x-placement^=bottom] [data-animation=shift-toward][data-state=visible]{opacity:1;-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateY(20px);transform:translateY(20px)}.tippy-popper[x-placement^=bottom] [data-animation=perspective]{-webkit-transform-origin:top;transform-origin:top}.tippy-popper[x-placement^=bottom] [data-animation=perspective][data-state=visible]{opacity:1;-webkit-transform:translateY(10px) rotateX(0);transform:translateY(10px) rotateX(0)}.tippy-popper[x-placement^=bottom] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:translateY(0) rotateX(-90deg);transform:translateY(0) rotateX(-90deg)}.tippy-popper[x-placement^=bottom] [data-animation=fade][data-state=visible]{opacity:1;-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-away][data-state=visible]{opacity:1;-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-away][data-state=hidden]{opacity:0;-webkit-transform:translateY(0);transform:translateY(0)}.tippy-popper[x-placement^=bottom] [data-animation=scale][data-state=visible]{opacity:1;-webkit-transform:translateY(10px) scale(1);transform:translateY(10px) scale(1)}.tippy-popper[x-placement^=bottom] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateY(0) scale(0);transform:translateY(0) scale(0)}.tippy-popper[x-placement^=left] .tippy-backdrop{border-radius:50% 0 0 50%}.tippy-popper[x-placement^=left] .tippy-roundarrow{right:-16px;-webkit-transform-origin:33.33333333% 50%;transform-origin:33.33333333% 50%}.tippy-popper[x-placement^=left] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(90deg);transform:rotate(90deg)}.tippy-popper[x-placement^=left] .tippy-arrow{border-left:7px solid #333;border-top:7px solid transparent;border-bottom:7px solid transparent;right:-7px;margin:3px 0;-webkit-transform-origin:0 50%;transform-origin:0 50%}.tippy-popper[x-placement^=left] .tippy-backdrop{-webkit-transform-origin:100% 0;transform-origin:100% 0}.tippy-popper[x-placement^=left] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(6) translate(40%,-50%);transform:scale(6) translate(40%,-50%);opacity:1}.tippy-popper[x-placement^=left] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(1.5) translate(40%,-50%);transform:scale(1.5) translate(40%,-50%);opacity:0}.tippy-popper[x-placement^=left] [data-animation=shift-toward][data-state=visible]{opacity:1;-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateX(-20px);transform:translateX(-20px)}.tippy-popper[x-placement^=left] [data-animation=perspective]{-webkit-transform-origin:right;transform-origin:right}.tippy-popper[x-placement^=left] [data-animation=perspective][data-state=visible]{opacity:1;-webkit-transform:translateX(-10px) rotateY(0);transform:translateX(-10px) rotateY(0)}.tippy-popper[x-placement^=left] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:translateX(0) rotateY(-90deg);transform:translateX(0) rotateY(-90deg)}.tippy-popper[x-placement^=left] [data-animation=fade][data-state=visible]{opacity:1;-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-away][data-state=visible]{opacity:1;-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-away][data-state=hidden]{opacity:0;-webkit-transform:translateX(0);transform:translateX(0)}.tippy-popper[x-placement^=left] [data-animation=scale][data-state=visible]{opacity:1;-webkit-transform:translateX(-10px) scale(1);transform:translateX(-10px) scale(1)}.tippy-popper[x-placement^=left] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateX(0) scale(0);transform:translateX(0) scale(0)}.tippy-popper[x-placement^=right] .tippy-backdrop{border-radius:0 50% 50% 0}.tippy-popper[x-placement^=right] .tippy-roundarrow{left:-16px;-webkit-transform-origin:66.66666666% 50%;transform-origin:66.66666666% 50%}.tippy-popper[x-placement^=right] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}.tippy-popper[x-placement^=right] .tippy-arrow{border-right:7px solid #333;border-top:7px solid transparent;border-bottom:7px solid transparent;left:-7px;margin:3px 0;-webkit-transform-origin:100% 50%;transform-origin:100% 50%}.tippy-popper[x-placement^=right] .tippy-backdrop{-webkit-transform-origin:-100% 0;transform-origin:-100% 0}.tippy-popper[x-placement^=right] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(6) translate(-140%,-50%);transform:scale(6) translate(-140%,-50%);opacity:1}.tippy-popper[x-placement^=right] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(1.5) translate(-140%,-50%);transform:scale(1.5) translate(-140%,-50%);opacity:0}.tippy-popper[x-placement^=right] [data-animation=shift-toward][data-state=visible]{opacity:1;-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateX(20px);transform:translateX(20px)}.tippy-popper[x-placement^=right] [data-animation=perspective]{-webkit-transform-origin:left;transform-origin:left}.tippy-popper[x-placement^=right] [data-animation=perspective][data-state=visible]{opacity:1;-webkit-transform:translateX(10px) rotateY(0);transform:translateX(10px) rotateY(0)}.tippy-popper[x-placement^=right] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:translateX(0) rotateY(90deg);transform:translateX(0) rotateY(90deg)}.tippy-popper[x-placement^=right] [data-animation=fade][data-state=visible]{opacity:1;-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-away][data-state=visible]{opacity:1;-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-away][data-state=hidden]{opacity:0;-webkit-transform:translateX(0);transform:translateX(0)}.tippy-popper[x-placement^=right] [data-animation=scale][data-state=visible]{opacity:1;-webkit-transform:translateX(10px) scale(1);transform:translateX(10px) scale(1)}.tippy-popper[x-placement^=right] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateX(0) scale(0);transform:translateX(0) scale(0)}.tippy-tooltip{position:relative;color:#fff;border-radius:4px;font-size:.9rem;padding:.3rem .6rem;text-align:center;will-change:transform;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;background-color:#333}.tippy-tooltip[data-size=small]{padding:.2rem .4rem;font-size:.75rem}.tippy-tooltip[data-size=large]{padding:.4rem .8rem;font-size:1rem}.tippy-tooltip[data-animatefill]{overflow:hidden;background-color:transparent}.tippy-tooltip[data-animatefill] .tippy-content{transition:-webkit-clip-path cubic-bezier(.46,.1,.52,.98);transition:clip-path cubic-bezier(.46,.1,.52,.98);transition:clip-path cubic-bezier(.46,.1,.52,.98),-webkit-clip-path cubic-bezier(.46,.1,.52,.98)}.tippy-tooltip[data-interactive],.tippy-tooltip[data-interactive] path{pointer-events:auto}.tippy-tooltip[data-inertia][data-state=visible]{transition-timing-function:cubic-bezier(.53,2,.36,.85)}.tippy-tooltip[data-inertia][data-state=hidden]{transition-timing-function:ease}.tippy-arrow,.tippy-roundarrow{position:absolute;width:0;height:0}.tippy-roundarrow{width:24px;height:8px;fill:#333;pointer-events:none}.tippy-backdrop{position:absolute;will-change:transform;background-color:#333;border-radius:50%;width:26%;left:50%;top:50%;z-index:-1;transition:all cubic-bezier(.46,.1,.52,.98);-webkit-backface-visibility:hidden;backface-visibility:hidden}.tippy-backdrop:after{content:"";float:left;padding-top:100%}body:not(.tippy-touch) .tippy-tooltip[data-animatefill][data-state=visible] .tippy-content{-webkit-clip-path:ellipse(100% 100% at 50% 50%);clip-path:ellipse(100% 100% at 50% 50%)}body:not(.tippy-touch) .tippy-tooltip[data-animatefill][data-state=hidden] .tippy-content{-webkit-clip-path:ellipse(5% 50% at 50% 50%);clip-path:ellipse(5% 50% at 50% 50%)}body:not(.tippy-touch) .tippy-popper[x-placement=right] .tippy-tooltip[data-animatefill][data-state=visible] .tippy-content{-webkit-clip-path:ellipse(135% 100% at 0 50%);clip-path:ellipse(135% 100% at 0 50%)}body:not(.tippy-touch) .tippy-popper[x-placement=right] .tippy-tooltip[data-animatefill][data-state=hidden] .tippy-content{-webkit-clip-path:ellipse(40% 100% at 0 50%);clip-path:ellipse(40% 100% at 0 50%)}body:not(.tippy-touch) .tippy-popper[x-placement=left] .tippy-tooltip[data-animatefill][data-state=visible] .tippy-content{-webkit-clip-path:ellipse(135% 100% at 100% 50%);clip-path:ellipse(135% 100% at 100% 50%)}body:not(.tippy-touch) .tippy-popper[x-placement=left] .tippy-tooltip[data-animatefill][data-state=hidden] .tippy-content{-webkit-clip-path:ellipse(40% 100% at 100% 50%);clip-path:ellipse(40% 100% at 100% 50%)}@media (max-width:360px){.tippy-popper{max-width:96%;max-width:calc(100% - 20px)}}'; const version = '2.6.0'; var isBrowser = typeof window !== 'undefined'; var isIE = isBrowser && /MSIE |Trident\//.test(navigator.userAgent); var browser = {};
  isBrowser && (browser.supported = 'requestAnimationFrame' in window, browser.supportsTouch = 'ontouchstart' in window, browser.usingTouch = !1, browser.dynamicInputDetection = !0, browser.iOS = /iPhone|iPad|iPod/.test(navigator.platform) && !window.MSStream, browser.onUserInputChange = function () {}); for (var selectors = {
      POPPER: '.tippy-popper', TOOLTIP: '.tippy-tooltip', CONTENT: '.tippy-content', BACKDROP: '.tippy-backdrop', ARROW: '.tippy-arrow', ROUND_ARROW: '.tippy-roundarrow', REFERENCE: '[data-tippy]',
    }, defaults = {
      placement: 'top', livePlacement: !0, trigger: 'mouseenter focus', animation: 'shift-away', html: !1, animateFill: !0, arrow: !1, delay: [0, 20], duration: [350, 300], interactive: !1, interactiveBorder: 2, theme: 'dark', size: 'regular', distance: 10, offset: 0, hideOnClick: !0, multiple: !1, followCursor: !1, inertia: !1, updateDuration: 350, sticky: !1, appendTo() { return document.body; }, zIndex: 9999, touchHold: !1, performance: !1, dynamicTitle: !1, flip: !0, flipBehavior: 'flip', arrowType: 'sharp', arrowTransform: '', maxWidth: '', target: null, allowTitleHTML: !0, popperOptions: {}, createPopperInstanceOnInit: !1, onShow() {}, onShown() {}, onHide() {}, onHidden() {},
    }, defaultsKeys = browser.supported && Object.keys(defaults), classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) throw new TypeError('Cannot call a class as a function'); }, createClass = (function () { function defineProperties(target, props) { for (let i = 0; i < props.length; i++) { const descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 'value' in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor; }; }()), _extends = Object.assign || function (target) { for (let i = 1; i < arguments.length; i++) { const source = arguments[i]; for (const key in source)Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]); } return target; }, isBrowser$1 = typeof window !== 'undefined' && typeof document !== 'undefined', longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'], timeoutDuration = 0, i = 0; i < longerTimeoutBrowsers.length; i += 1) if (isBrowser$1 && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) { timeoutDuration = 1; break; } const supportsMicroTasks = isBrowser$1 && window.Promise; const debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce; var isIE11 = isBrowser$1 && !(!window.MSInputMethodContext || !document.documentMode); var isIE10 = isBrowser$1 && /MSIE 10/.test(navigator.userAgent); const classCallCheck$1 = function (instance, Constructor) { if (!(instance instanceof Constructor)) throw new TypeError('Cannot call a class as a function'); }; const createClass$1 = (function () { function defineProperties(target, props) { for (let i = 0; i < props.length; i++) { const descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 'value' in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor; }; }()); var defineProperty$1 = function (obj, key, value) {
    return key in obj ? Object.defineProperty(obj, key, {
      value, enumerable: !0, configurable: !0, writable: !0,
    }) : obj[key] = value, obj;
  }; const _extends$1 = Object.assign || function (target) { for (let i = 1; i < arguments.length; i++) { const source = arguments[i]; for (const key in source)Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]); } return target; }; const placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start']; var validPlacements = placements.slice(3); var BEHAVIORS = { FLIP: 'flip', CLOCKWISE: 'clockwise', COUNTERCLOCKWISE: 'counterclockwise' }; const modifiers = {
    shift: { order: 100, enabled: !0, fn: shift },
    offset: {
      order: 200, enabled: !0, fn: offset, offset: 0,
    },
    preventOverflow: {
      order: 300, enabled: !0, fn: preventOverflow, priority: ['left', 'right', 'top', 'bottom'], padding: 5, boundariesElement: 'scrollParent',
    },
    keepTogether: { order: 400, enabled: !0, fn: keepTogether },
    arrow: {
      order: 500, enabled: !0, fn: arrow, element: '[x-arrow]',
    },
    flip: {
      order: 600, enabled: !0, fn: flip, behavior: 'flip', padding: 5, boundariesElement: 'viewport',
    },
    inner: { order: 700, enabled: !1, fn: inner },
    hide: { order: 800, enabled: !0, fn: hide },
    computeStyle: {
      order: 850, enabled: !0, fn: computeStyle, gpuAcceleration: !0, x: 'bottom', y: 'right',
    },
    applyStyle: {
      order: 900, enabled: !0, fn: applyStyle, onLoad: applyStyleOnLoad, gpuAcceleration: void 0,
    },
  }; const Defaults = {
    placement: 'bottom', positionFixed: !1, eventsEnabled: !0, removeOnDestroy: !1, onCreate() {}, onUpdate() {}, modifiers,
  }; var Popper = (function () { function Popper(reference, popper) { const _this = this; const options = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; classCallCheck$1(this, Popper), this.scheduleUpdate = function () { return requestAnimationFrame(_this.update); }, this.update = debounce(this.update.bind(this)), this.options = { ...Popper.Defaults, ...options }, this.state = { isDestroyed: !1, isCreated: !1, scrollParents: [] }, this.reference = reference && reference.jquery ? reference[0] : reference, this.popper = popper && popper.jquery ? popper[0] : popper, this.options.modifiers = {}, Object.keys({ ...Popper.Defaults.modifiers, ...options.modifiers }).forEach((name) => { _this.options.modifiers[name] = { ...Popper.Defaults.modifiers[name] || {}, ...(options.modifiers ? options.modifiers[name] : {}) }; }), this.modifiers = Object.keys(this.options.modifiers).map((name) => ({ name, ..._this.options.modifiers[name] })).sort((a, b) => a.order - b.order), this.modifiers.forEach((modifierOptions) => { modifierOptions.enabled && isFunction(modifierOptions.onLoad) && modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state); }), this.update(); const { eventsEnabled } = this.options; eventsEnabled && this.enableEventListeners(), this.state.eventsEnabled = eventsEnabled; } return createClass$1(Popper, [{ key: 'update', value() { return update.call(this); } }, { key: 'destroy', value() { return destroy.call(this); } }, { key: 'enableEventListeners', value() { return enableEventListeners.call(this); } }, { key: 'disableEventListeners', value() { return disableEventListeners.call(this); } }]), Popper; }()); Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils, Popper.placements = placements, Popper.Defaults = Defaults; let matches = {}; if (isBrowser) { const e = Element.prototype; matches = e.matches || e.matchesSelector || e.webkitMatchesSelector || e.mozMatchesSelector || e.msMatchesSelector || function (s) { for (var matches = (this.document || this.ownerDocument).querySelectorAll(s), i = matches.length; --i >= 0 && matches.item(i) !== this;);return i > -1; }; } var matches$1 = matches; var key = {}; const store = function (data) { return function (k) { return k === key && data; }; }; var Tippy = (function () {
    function Tippy(config) { classCallCheck(this, Tippy); for (const _key in config) this[_key] = config[_key]; this.state = { destroyed: !1, visible: !1, enabled: !0 }, this._ = store({ mutationObservers: [] }); } return createClass(Tippy, [{ key: 'enable', value() { this.state.enabled = !0; } }, { key: 'disable', value() { this.state.enabled = !1; } }, {
      key: 'show',
      value(duration) {
        const _this = this; if (!this.state.destroyed && this.state.enabled) {
          const { popper } = this; const { reference } = this; const { options } = this; const _getInnerElements = getInnerElements(popper); const { tooltip } = _getInnerElements; const { backdrop } = _getInnerElements; const
            { content } = _getInnerElements; if ((!options.dynamicTitle || reference.getAttribute('data-original-title')) && !reference.hasAttribute('disabled')) { if (!reference.refObj && !document.documentElement.contains(reference)) return void this.destroy(); options.onShow.call(popper, this), duration = getValue(void 0 !== duration ? duration : options.duration, 0), applyTransitionDuration([popper, tooltip, backdrop], 0), popper.style.visibility = 'visible', this.state.visible = !0, _mount.call(this, () => { if (_this.state.visible) { if (_hasFollowCursorBehavior.call(_this) || _this.popperInstance.scheduleUpdate(), _hasFollowCursorBehavior.call(_this)) { _this.popperInstance.disableEventListeners(); const delay = getValue(options.delay, 0); const { lastTriggerEvent } = _this._(key); lastTriggerEvent && _this._(key).followCursorListener(delay && _this._(key).lastMouseMoveEvent ? _this._(key).lastMouseMoveEvent : lastTriggerEvent); }applyTransitionDuration([tooltip, backdrop, backdrop ? content : null], duration), backdrop && getComputedStyle(backdrop)[prefix('transform')], options.interactive && reference.classList.add('tippy-active'), options.sticky && _makeSticky.call(_this), setVisibilityState([tooltip, backdrop], 'visible'), _onTransitionEnd.call(_this, duration, () => { options.updateDuration || tooltip.classList.add('tippy-notransition'), options.interactive && focus(popper), reference.setAttribute('aria-describedby', `tippy-${_this.id}`), options.onShown.call(popper, _this); }); } }); }
        }
      },
    }, {
      key: 'hide',
      value(duration) {
        const _this2 = this; if (!this.state.destroyed && this.state.enabled) {
          const { popper } = this; const { reference } = this; const { options } = this; const _getInnerElements2 = getInnerElements(popper); const { tooltip } = _getInnerElements2; const { backdrop } = _getInnerElements2; const
            { content } = _getInnerElements2; options.onHide.call(popper, this), duration = getValue(void 0 !== duration ? duration : options.duration, 1), options.updateDuration || tooltip.classList.remove('tippy-notransition'), options.interactive && reference.classList.remove('tippy-active'), popper.style.visibility = 'hidden', this.state.visible = !1, applyTransitionDuration([tooltip, backdrop, backdrop ? content : null], duration), setVisibilityState([tooltip, backdrop], 'hidden'), options.interactive && options.trigger.indexOf('click') > -1 && focus(reference), _onTransitionEnd.call(this, duration, () => { !_this2.state.visible && options.appendTo.contains(popper) && (_this2._(key).isPreparingToShow || (document.removeEventListener('mousemove', _this2._(key).followCursorListener), _this2._(key).lastMouseMoveEvent = null), _this2.popperInstance && _this2.popperInstance.disableEventListeners(), reference.removeAttribute('aria-describedby'), options.appendTo.removeChild(popper), options.onHidden.call(popper, _this2)); });
        }
      },
    }, { key: 'destroy', value() { const _this3 = this; const destroyTargetInstances = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]; if (!this.state.destroyed) { this.state.visible && this.hide(0), this.listeners.forEach((listener) => { _this3.reference.removeEventListener(listener.event, listener.handler); }), this.title && this.reference.setAttribute('title', this.title), delete this.reference._tippy; const attributes = ['data-original-title', 'data-tippy', 'data-tippy-delegate']; attributes.forEach((attr) => { _this3.reference.removeAttribute(attr); }), this.options.target && destroyTargetInstances && toArray(this.reference.querySelectorAll(this.options.target)).forEach((child) => child._tippy && child._tippy.destroy()), this.popperInstance && this.popperInstance.destroy(), this._(key).mutationObservers.forEach((observer) => { observer.disconnect(); }), this.state.destroyed = !0; } } }]), Tippy;
  }()); var idCounter = 1; var eventListenersBound = !1; var useCapture = !1; return tippy.version = version, tippy.browser = browser, tippy.defaults = defaults, tippy.one = function (selector, options) { return tippy(selector, options, !0).tooltips[0]; }, tippy.disableAnimations = function () { defaults.updateDuration = defaults.duration = 0, defaults.animateFill = !1; }, tippy.useCapture = function () { useCapture = !0; }, injectCSS(styles), tippy;
})), jQuery(document).ready(($) => {
  function disable_module_fields_used() { $('#crmservice-integration-settings .row-field .col-module select').each(function () { this.value !== '0' && $(`#crmservice-integration-settings .row-field .col-module select option[value="${this.value}"]`).attr('disabled', 'true'); }); } function maybe_show_module_field_notices() { $('.crmservice-metabox-connections-wrap .row-field .col-module select, .crmservice-metabox-static-fields-wrap .row-field .col-module select').each(function () { selection_type = $(this).find('option:selected').attr('data-type'), selection_type !== 'Select' && selection_type !== 'MultiSelect' || (module_field = _.findWhere(module_fields, { name: $(this).find('option:selected').val() }), options = $.map(module_field.picklist_values, (val, i) => i), $(this).closest('.col-module').find('p.select-options span').html(options.join(', ')), $(this).closest('.col-module').find('p.select-options').show()), selection_uitype = $(this).find('option:selected').attr('data-uitype'), selection_uitype !== null && void 0 !== selection_uitype && (selection_uitype = selection_uitype.toString(), selection_uitype !== '53' && selection_uitype !== '700' && selection_uitype !== '702' && selection_uitype !== '704' && selection_uitype !== '101' || $(this).closest('.col-module').find('p.uitype-user-relation').show()); }); } function populate_form_fields() { $('.crmservice-metabox-connections-wrap').show(), $('.crmservice-metabox-static-fields-wrap').show(), x = 0, $.each(form_fields, (i, item) => { row = $('.crmservice-metabox-connections-wrap .row-field-base').clone(), row = $(row), row.removeAttr('style').removeClass('row-field-base'), row.attr('id', `form-row-${i}`).find('.col-form p').html(item), row.find('input[name="form_field"]').attr('name', `crmservice_connections[${x}][form_field]`).val(i), row.find('[name="module_field"]').attr('name', `crmservice_connections[${x}][module_field]`), $('.crmservice-metabox-connections-wrap').append(row), x++; }); } function populate_module_fields() { $('.crmservice-metabox-connections-wrap').show(), $('.crmservice-metabox-static-fields-wrap').show(), $.each(module_fields, (i, item) => { $('.crmservice-metabox-connections-wrap .col-module select').append($('<option>', { value: item.name, text: `${item.label} (${item.type})`, 'data-type': item.type })), $('.crmservice-metabox-static-fields-wrap .col-module select').append($('<option>', { value: item.name, text: `${item.label} (${item.type})`, 'data-type': item.type })); }), $('.crmservice-metabox-connections-wrap .col-module p.select-options').hide(), $('.crmservice-metabox-connections-wrap .col-module p.uitype-user-relation').hide(); }tippy('span.status', {
    arrow: !0, arrowType: 'sharp', size: 'small', placement: 'top-start',
  }); var form_fields = []; var module_fields = []; disable_module_fields_used(), $('select[name="crmservice_module"] option:selected').length && $.ajax({
    type: 'GET', dataType: 'json', data: { module: $('select[name="crmservice_module"] option:selected').val() }, url: `${crmservice.root}crmservice/v1/module/fields`, beforeSend(xhr) { xhr.setRequestHeader('X-WP-Nonce', crmservice.nonce); }, success(data) { module_fields = data, maybe_show_module_field_notices(); },
  }), $(document).on('change', '#crmservice-integration-settings .row-field .col-module select', function () { $(this).parent('.col-module').find('input').val(this.value), $('#crmservice-integration-settings .row-field .col-module select option').attr('disabled', !1), disable_module_fields_used(); }), $(document).on('change', 'select[name="crmservice_form"]', function () {
    $('.crmservice-metabox-connections-wrap .row-field:not(.row-field-base)').remove(), $.ajax({
      type: 'GET', dataType: 'json', data: { form: this.value }, url: `${crmservice.root}crmservice/v1/form/fields`, beforeSend(xhr) { xhr.setRequestHeader('X-WP-Nonce', crmservice.nonce); }, success(data) { form_fields = data.fields, populate_form_fields(); },
    });
  }), $(document).on('change', 'select[name="crmservice_module"]', function () {
    $('.crmservice-metabox-connections-wrap .col-module select').empty().append('<option>Select</option>'), $('.crmservice-metabox-static-fields-wrap .col-module select').empty().append('<option>Select</option>'), $.ajax({
      type: 'GET', dataType: 'json', data: { module: this.value }, url: `${crmservice.root}crmservice/v1/module/fields`, beforeSend(xhr) { xhr.setRequestHeader('X-WP-Nonce', crmservice.nonce); }, success(data) { module_fields = data, populate_module_fields(); },
    });
  }), $(document).on('change', '.crmservice-metabox-connections-wrap .col-module select, .crmservice-metabox-static-fields-wrap .col-module select', function () { $(this).closest('.col-module').find('p.select-options').hide(), $(this).closest('.col-module').find('p.uitype-user-relation').hide(), selection_type = $(this).find('option:selected').attr('data-type'), selection_type !== 'Select' && selection_type !== 'MultiSelect' || (module_field = _.findWhere(module_fields, { name: $(this).find('option:selected').val() }), options = $.map(module_field.picklist_values, (val, i) => i), $(this).closest('.col-module').find('p.select-options span').html(options.join(', ')), $(this).closest('.col-module').find('p.select-options').show()), selection_uitype = $(this).find('option:selected').attr('data-uitype'), selection_uitype !== null && void 0 !== selection_uitype && (selection_uitype = selection_uitype.toString(), selection_uitype !== '53' && selection_uitype !== '700' && selection_uitype !== '702' && selection_uitype !== '704' && selection_uitype !== '101' || $(this).closest('.col-module').find('p.uitype-user-relation').show()); }), $('.crmservice-metabox-static-fields-wrap .row-footer button').on('click', (e) => { e.preventDefault(), x = $('.crmservice-metabox-static-fields-wrap .row-field').length, x++, row = $('.crmservice-metabox-static-fields-wrap .row-field-base').clone(), row = $(row), row.removeAttr('style').removeClass('row-field-base'), row.find('select[name="crmservice_static_fields[0]"]').attr('name', `crmservice_static_fields[${x}]`), row.find('input[name="crmservice_static_fields[0]"]').attr('name', `crmservice_static_fields[${x}]`), row.find('input[name="crmservice_static_fields_values[0]"]').attr('name', `crmservice_static_fields_values[${x}]`), $('.crmservice-metabox-static-fields-wrap .row-footer').before(row); }), $(document).on('change', '#crmservice-integration-settings .col-module select', function () { $(`input[name="${$(this).attr('name')}"]`).val(this.value); }), $(document).on('click', '.crmservice-metabox-static-fields-wrap .row-field button.delete', function (e) { e.preventDefault(), $(this).closest('.row-field').remove(); });
});
